# 암호학 & 패스워드 보안 실습 (Docker)

이 프로젝트는 현대적인 파일 암호화 방식과 구식 패스워드 시스템의 취약점을 **상호작용 가능한 웹 애플리케이션**을 통해 직접 비교하고 체험하며, **"왜 강력한 보안 장치가 필수적인가?"** 에 대한 해답을 스스로 찾아가는 교육적인 실습입니다.

Docker를 사용하여 누구나 단 한 줄의 명령어로 로컬 환경에서 웹 기반의 암호화, 복호화, 그리고 보안 공격 시뮬레이션을 실행해볼 수 있습니다.

---

### 핵심 질문: 왜 이 프로젝트를 만들었는가?

많은 개발자가 암호화 라이브러리를 사용하면서도 그 내부 동작 원리나 보안 철학에 대해서는 깊이 고민하지 않습니다. 이 프로젝트는 두 가지 대조적인 시나리오를 통해 그 "왜?"를 명확히 보여줍니다.

1.  **Part 1 (방어): 왜 '솔트(Salt)'와 '키 유도 함수(KDF)'가 필수적인가?**
    *   **솔트 (Salt)**: 같은 비밀번호를 사용하더라도, 암호화할 때마다 매번 다른 '솔트'라는 무작위 데이터를 추가합니다. 결과적으로, 동일한 비밀번호로 여러 파일을 암호화해도 모두 다른 암호문이 생성됩니다.
    *   **키 유도 함수 (KDF, 예: PBKDF2)**: 사용자가 입력한 간단한 비밀번호를 그대로 사용하지 않고, 솔트와 섞어 수만 번의 해시 연산을 반복하여 복잡하고 예측 불가능한 최종 암호화 키를 만들어냅니다. 이 과정은 의도적으로 시간을 소모시켜, 공격자가 무차별 대입 공격(Brute-force)을 시도하는 비용을 기하급수적으로 증가시킵니다.

2.  **Part 2 (증명): 왜 안전한 암호화는 사전 공격에 뚫리지 않는가?**
    *   이 시뮬레이션은 Part 1의 안전한 방식으로 암호화된 파일에 사전 공격을 직접 시도합니다.
    *   결과는 당연히 **실패**하며, 그 과정을 통해 사용자는 "공격자가 비밀번호를 알아도, 고유한 솔트를 모르기 때문에 절대 원본 키를 만들 수 없다"는 사실을 눈으로 확인하게 됩니다. 이를 통해 '솔트'의 중요성을 명확히 체감할 수 있습니다.

---

### 프로젝트 구조

*   `app.py`: **Flask**를 사용한 메인 웹 애플리케이션.
*   `vault.py`: 파일 암호화/복호화 핵심 로직 모듈.
*   `cracker.py`: 보안 공격 시뮬레이션 로직 모듈.
*   `templates/index.html`: 사용자가 상호작용하는 **웹 프론트엔드**.
*   `Dockerfile` & `docker-compose.yml`: **Docker**를 이용한 애플리케이션 컨테이너화 설정.
*   `wordlist.txt`: 사전 공격 시뮬레이션에 사용할 단어 목록.
*   `requirements.txt`: 프로젝트 실행에 필요한 파이썬 라이브러리 목록.
*   `start-server.bat`: Windows 사용자를 위한 **원클릭 서버 시작 스크립트**.
*   `.gitignore`: Git 저장소에 포함되지 않을 파일 및 폴더 목록.
*   `README.md`: 바로 이 파일. 프로젝트의 철학과 사용법을 안내합니다.
*   `LICENSE`: 프로젝트의 라이선스 정보 (MIT License).

---

### 실행 방법 (Docker)

1.  설치 및 실행 방법 (Docker 사용)
이 애플리케이션은 Docker를 통해 가장 쉽게 실행할 수 있습니다. 로컬 컴퓨터에 [Docker Desktop](https://www.docker.com/products/docker-desktop/)이 설치되어 있어야 합니다.
2.  이 프로젝트를 컴퓨터에 다운로드하거나 `git clone` 합니다.
3.  프로젝트 폴더(`crypto-password-lab`)로 이동합니다.

#### Windows 사용자 (원클릭 실행)

*   프로젝트 폴더 내의 **`start-server.bat` 파일을 더블클릭**합니다.
*   자동으로 터미널 창이 열리고 Docker 컨테이너가 빌드 및 실행됩니다.

#### 그 외 운영체제 사용자 또는 수동 실행

*   터미널을 열고 프로젝트 폴더로 이동합니다.
*   아래 명령어를 실행하여 Docker 컨테이너를 빌드하고 실행합니다. (`--build` 옵션은 이미지가 없거나 변경사항이 있을 때 새로 빌드합니다.)

    ```bash
    docker-compose up --build
    ```

5.  빌드가 완료되면, 웹 브라우저를 열고 아래 주소로 접속합니다.

    > **http://localhost:5000**

---

### 사용 방법 (웹 애플리케이션)

웹 페이지의 안내에 따라 각 기능을 사용해 보세요.

#### Part 1: 안전하게 파일 잠그기/열기

*   **파일 자동 삭제**: 파일 암호화/복호화 및 다운로드가 완료되면, 서버에 임시로 저장되었던 파일들은 자동으로 삭제되어 개인 정보 보호를 강화합니다.

1.  **암호화**:
    *   '파일 선택' 버튼을 눌러 암호화할 파일을 선택합니다.
    *   사용할 비밀번호를 입력합니다.
    *   '파일 암호화' 버튼을 클릭합니다. 버튼이 "처리 중..."으로 바뀌며 작업이 진행됩니다.
    *   성공 시 암호화된 파일(`파일명_encrypted.확장자`)이 자동으로 다운로드됩니다.

2.  **복호화**:
    *   암호화된 파일을 선택합니다.
    *   암호화 시 사용했던 비밀번호를 정확히 입력합니다.
    *   '파일 복호화' 버튼을 클릭합니다.
    *   성공 시 원본 파일이 자동으로 다운로드됩니다.

#### Part 2: 안전한 암호화 크랙 시도하기

*   '안전한 암호화 크랙 시도' 버튼을 클릭하면, Part 1의 방식으로 암호화된 파일에 대한 사전 공격 시뮬레이션이 시작됩니다.
*   결과 창에 크랙이 **실패**하는 과정과 그 이유에 대한 상세한 설명이 표시됩니다.

---

### 학습한 보안 개념

*   **해시 (Hash)**: 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수. 입력값이 약간만 달라도 결과가 완전히 달라지며, 결과값으로 입력값을 역산할 수 없는 단방향성의 특징을 가집니다. (예: SHA-256)
*   **솔트 (Salt)**: 패스워드 해싱 시 추가하는 무작위 데이터. 동일한 패스워드라도 서로 다른 해시 값을 갖게 만들어, 미리 계산된 해시 테이블(레인보우 테이블)을 사용한 공격을 방어합니다.
*   **키 유도 함수 (KDF, Key Derivation Function)**: 사용자의 기본 비밀번호로부터 암호학적으로 더 안전한 키를 생성하는 함수. 의도적으로 많은 연산을 수행하여 무차별 대입 공격의 속도를 늦춥니다. (예: PBKDF2, Scrypt, Argon2)
*   **대칭키 암호화 (Symmetric-key Cryptography)**: 암호화와 복호화에 동일한 키를 사용하는 암호화 방식. (예: AES)
*   **AES-GCM**: 데이터의 기밀성(암호화)뿐만 아니라 무결성과 인증까지 함께 제공하는 매우 안전한 블록 암호 운용 모드입니다.

---

### 라이선스

이 프로젝트는 [MIT License](LICENSE) 하에 배포됩니다.
